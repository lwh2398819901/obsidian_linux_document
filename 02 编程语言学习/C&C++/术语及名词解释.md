
# 内存管理
[基础知识篇——堆内存和栈内存](https://blog.csdn.net/qq_41498261/article/details/83583466)
## RAII
RAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父 Bjarne Stroustrup 提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。

参考链接<https://blog.csdn.net/yyxyong/article/details/76099721>

## 堆

 **“free store” VS “heap”**
 
当我问你C++的内存布局时，你大概会回答：
> “在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区”。

如果我接着问你自由存储区与堆有什么区别，你或许这样回答：
> “malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”

这样听起来似乎也没错，但如果我接着问：
> 自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？

尽管C++标准没有要求，但很多编译器的new/delete都是以malloc/free为基础来实现的。那么请问：借以malloc实现的new，所申请的内存是在堆上还是在自由存储区上？

从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，<span style="background:#A0CCF6">所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现</span>，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以<span style="background:#F0A7D8">通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了</span>。我们所需要记住的就是：

> 堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。

 **结论**
- 自由存储是C++中通过new与delete动态分配和释放对象的**抽象概念**，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
    
- new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
    
- 堆与自由存储区还是有区别的，它们并非等价。


[C++ 自由存储区是否等价于堆？](https://www.cnblogs.com/QG-whz/p/5060894.html)
## 栈

[基础知识篇——堆内存和栈内存](https://blog.csdn.net/qq_41498261/article/details/83583466)
## 堆（数据结构）


## 栈 （数据结构）

## POD
在 C++ 中，POD（Plain Old Data） 是一种数据类型分类，它指的是满足以下条件的类或结构体：
1. **标准布局**（Standard Layout）：POD 类型的内存布局是简单的、连续的，与 C 语言中的结构体类似，没有类成员函数，也没有虚函数表等额外信息。
2. **无非静态成员函数**：POD 类型不能包含任何非静态成员函数。
3. **没有基类**：POD 类型不能有任何基类，即不能是从其他类继承而来的。
4. **所有非静态数据成员都是 POD 类型**：如果一个类内部含有其他类类型的成员，则这些嵌套类也必须是 POD 类型。
5. **没有 virtual、private、protected 关键字**：POD 类型不使用这些关键字来修饰成员或类本身。
6. **可标准初始化**（Trivially Default Constructible, Trivially Copyable 等）：POD 类型可以进行默认构造、复制构造和赋值操作，并且这些操作都是平凡的（trivial），即不会有任何特别的操作，只是简单地复制内存。

简单来说，<font color=#2485E3>POD 类型就像是 C 语言中的简单结构体（int,double,char....）</font>，其数据可以直接进行位级别的复制（memcpy）、初始化和对齐，这对于底层编程、内存管理和跨编译单元的数据交互非常重要。C++11 标准引入了 `std::is_pod` 这个类型 trait，可以用来检查一个类型是否为 POD 类型。





